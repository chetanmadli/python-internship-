39] POWER OF TWO

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.


Example 1:

Input: n = 1
Output: true
Explanation: 20 = 1

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n&(n-1)==0:
            return True
        elif n==0:
            return False
        else:
            return False
==============================================================================================
40] There is a hidden integer array arr that consists of n non-negative integers.

It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].

You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].

Return the original array arr. It can be proved that the answer exists and is unique.

Example 1:

Input: encoded = [1,2,3], first = 1
Output: [1,0,2,1]
Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr=[]
        arr.append(first)
        for i in encoded:
            arr.append(arr[-1]^i)
        return arr

=============================================================================================
41]You are given an array of positive integers nums.

You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.

For example, the binary representation of 5, which is "101", does not have any trailing zeros, whereas the binary representation of 4, which is "100", has two trailing zeros.

Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.

Example 1:

Input: nums = [1,2,3,4,5]
Output: true
Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation "110" with one trailing zero.

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        count=0
        for i in nums:
            if i%2==0:
                count+=1
        if count>=2:
            return True
        else:
            return False

===============================================================================================

42] Given an integer x, return true if x is a palindrome, and false otherwise.
Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if(x<0):
            return False
        rev=0
        original=x
        while(x):
            rev=rev*10+x%10
            x//=10
        if(original==rev):
            return True
        else:
            return False
================================================================================================

43]Removing index value in tuple.

t=tuple(map(int,input("Enter the tuple: ").split()))
i=int(input("Enter the index value to remove: "))
t1=(t[:i])
t2=(t[i+1:]) 
t3=t1+t2
print(t3)

================================================================================================

44] count repeated numbers in tuple and print

================================================================================================
45] Find the most frequent element in a list.

================================================================================================
46] MAJORITY ELEMENTS

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Example 1:

Input: nums = [3,2,3]
Output: 3

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n=len(nums)
        d={}
        for i in nums:
            if i not in d:
                d[i]=1
            else:
                d[i]+=1
        for i in d:
            if d[i]>n//2:
                return I

================================================================================================
47] Longest hormonious subsequence

We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.

Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.

 Example 1:

Input: nums = [1,3,2,2,5,2,3,7]

Output: 5

class Solution:
    def findLHS(self, nums: List[int]) -> int:
        d={}
        for i in nums:
            if(i not in d):
                d[i]=1
            else:
                d[i]+=1
        m=0
        for i in d:
            if(i+1 in d and d[i]+d[i+1]>m):
                m=d[i]+d[i+1]
        return m

=================================================================================================
49] Numnber of good pairs

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

 Example 1:

Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.

class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        d={}
        p=0
        for num in nums:
            if num in d:
                p+=d[num]
                d[num]+=1
            else:
                d[num]=1
        return p

==================================================================================================

50] Intersectionm of two array.
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1=set(nums1)
        set2=set(nums2)
        return list(set1 & set2)